!function(){function r(e){var t=n[e];return"string"==typeof t&&Function("module","exports","require","eval("+JSON.stringify(t+"\n//@ sourceURL=/"+e)+")").call((n[e]=t={exports:{}}).exports,t,t.exports,r),t.exports}var n=["var Subscription = require(1)\r\n\r\nexports = module.exports = Bus\r\n\r\nfunction Bus (listeners) {\r\n    // Using discriptor to prevent non-subTopic properties from being enumerable\r\n    Object.defineProperty(this, '_listeners', {\r\n        value : listeners && Object.prototype.toString.call(listeners) === '[object Array]'\r\n            ? listeners \r\n            : [],\r\n        writable : true\r\n    })\r\n}\r\n\r\nvar proto = Bus.prototype\r\n\r\nexports.mixin = function (target) {\r\n    Bus.call(target)\r\n    Object.keys(proto).forEach(function (key) {\r\n        if ( !target.hasOwnProperty(key) ) {\r\n            Object.defineProperty(target, key, { \r\n                value: proto[key], \r\n                writable:true,\r\n                configurable:true \r\n            })\r\n        }\r\n    })\r\n    return target\r\n}\r\n\r\n/**\r\n * Iterate over a list of listeners invoking each one\r\n * @param  {Array}   topics should be an array of listener arrays from the topics objects you wish to invoke\r\n * @param  {Any}     data   whatever you want passed to each of the subscribers\r\n * @return {Boolean}        true if no listeners prevented propagation\r\n */\r\nexports.invokeList = invokeList\r\nfunction invokeList (topics, data) {\r\n    var len = topics.length, i, listeners\r\n    while ( len-- ) {\r\n        listeners = topics[len]\r\n        i = listeners.length\r\n        if ( i > 0 ) {\r\n            do {\r\n                // Returning false from a handler will prevent any further subscriptions from being notified\r\n                if ( listeners[--i].trigger(data) === false ) {\r\n                    return false\r\n                }\r\n            } while ( i )\r\n        }\r\n    }\r\n    return true\r\n}\r\n\r\nfunction insertListener (node, subscriptionData) {\r\n    var listeners = node._listeners.slice(),\r\n        priority = subscriptionData.priority,\r\n        added = false\r\n    \r\n    for ( var i = 0, len = listeners.length; i < len; i++ ) {\r\n        if ( listeners[i].priority >= priority ) {\r\n            listeners.splice(i, 0, subscriptionData)\r\n            added = true\r\n            break\r\n        }\r\n    }\r\n    if ( !added )\r\n        listeners.push(subscriptionData)\r\n    \r\n    node._listeners = listeners\r\n}\r\n\r\nfunction removeListener (node, callback) {\r\n    var check\r\n    switch ( typeof callback ) {\r\n        case 'function':\r\n            check = function (listenerData) {\r\n                return listenerData.callback !== callback\r\n            }\r\n            break\r\n        case 'string':\r\n            check = function (listenerData) {\r\n                return listenerData.callback.name !== callback\r\n            }\r\n            break\r\n        case 'object':\r\n            check = function (listenerData) {\r\n                return listenerData !== callback\r\n            }\r\n            break\r\n        default:\r\n            // if the user didn't pass a callback, all listeners will be removed\r\n            check = function () {\r\n                return false\r\n            }\r\n    }\r\n    node._listeners = node._listeners.filter(check)\r\n}\r\n\r\n// Recursive collect with the ability to fork and combine\r\nexports.branchingCollect = branchingCollect\r\nfunction branchingCollect (node, directive) {\r\n    var i = 0,\r\n        len = directive.length,\r\n        direction,\r\n        key,\r\n        result = [node._listeners]\r\n    while ( i < len ) {\r\n        direction = directive[i++]\r\n        key = direction[0]\r\n        if ( key in node ) {\r\n            result = result.concat(branchingCollect(node[key], direction.slice(1)))\r\n        }\r\n    }\r\n    return result\r\n}\r\n\r\n// Takes an list of directions to follow and collects all listeners along the way\r\nexports.collect = collect\r\nfunction collect (node, directions) {\r\n    var result = [node._listeners],\r\n        len = directions.length,\r\n        i = 0\r\n    while ( i < len ) {\r\n        node = node[directions[i++]]\r\n        if ( node )\r\n            result.push(node._listeners)\r\n        else\r\n            break\r\n    }\r\n    return result\r\n}\r\n\r\n// Retieves a a sub-topic from the descending tree\r\nproto.get = function (directions, useforce) {\r\n    if ( ! directions )\r\n        return this\r\n    directions = directions.split('.')\r\n    var topic = this,\r\n        edge,\r\n        len = directions.length,\r\n        i = 0\r\n    \r\n    if ( len ) {\r\n        do {\r\n            edge = directions[i++]\r\n            if ( topic[edge] instanceof Bus )\r\n                topic = topic[edge]\r\n            else if ( topic[edge] )\r\n                throw 'namespace clash: '+edge\r\n            else if ( useforce )\r\n                topic = topic[edge] = new Bus\r\n            else\r\n                break\r\n        } while ( i < len )\r\n    }\r\n    return topic\r\n}\r\n\r\n/**\r\n * If any callback returns false we immediately exit otherwise we simply return true to indicate that all callbacks were fired without interference\r\n * @param  {String} topic   the event type\r\n * @param  {Any}    data    any data you want passed to the callbacks\r\n * @return {Boolean}\r\n */\r\nproto.publish = function (topic, data) {\r\n    if ( typeof topic === 'string' ) {\r\n        topic = collect(this, topic.split('.'))\r\n    } else {\r\n        data = topic\r\n        topic = [this._listeners]\r\n    }\r\n    return invokeList(topic, data)\r\n}\r\n\r\n//  _Method_ __on__\r\n//  \r\n//  +   _optional_ __string__ `topics` a ' ' separate list of topics In the format `lvl1.lvl2.lvl3.etc`\r\n//  +   _optional_ __object__ `context`\r\n//  +   __function__ `callback` the function to handle events. Should take one argument, `data`\r\n//  +   _optional_ __number__ `priority` 1 will trigger before 2 etc  \r\n//  \r\n// returns `listenerObject`\r\nproto.on = function (topics, context, callback, priority) {\r\n    switch ( arguments.length ) {  \r\n        case 3:\r\n            if (typeof callback === 'number') {\r\n                priority = callback\r\n                callback = context\r\n                context = window\r\n            } else\r\n                priority = 0\r\n            break\r\n        case 2:\r\n            callback = context\r\n            priority = 0\r\n            if ( typeof topics === 'string' ) {\r\n                context = window\r\n            } else {\r\n                context = topics\r\n                topics = ''\r\n            }\r\n            break\r\n        case 1:\r\n            callback = topics\r\n            topics = ''\r\n            context = window\r\n            priority = 0\r\n            break\r\n        case 0:\r\n            throw 'Insufficient arguments'\r\n    }\r\n\r\n    var listenerData = new Subscription(context, callback, priority)\r\n\r\n    // Multiple subscriptions can be set at the same time, in fact it is recommended as they end up sharing memory this way. No need to throw error for incorrect topic since accessing `split` on a non-string will throw an error anyway\r\n    topics.split(/\\s+/).forEach(function (directions) {\r\n        insertListener(this.get(directions, true), listenerData)\r\n    },this)\r\n    return listenerData\r\n}\r\n\r\n// Same api as on except as soon as one topic is triggered the listener will be removed from __all__ topics it was subscribed to in the `once` call\r\nproto.once = function (topics, context, callback, priority) {\r\n    switch ( arguments.length ) {  \r\n        case 3:\r\n            if (typeof callback === 'number') {\r\n                priority = callback\r\n                callback = context\r\n                context = window\r\n            } else\r\n                priority = 0\r\n            break\r\n        case 2:\r\n            callback = context\r\n            context = window\r\n            priority = 0\r\n            break\r\n        case 1:\r\n            callback = topics\r\n            topics = ''\r\n            context = window\r\n            priority = 0\r\n            break\r\n        case 0:\r\n            throw 'Insufficient arguments'\r\n    }\r\n    var listenerData = new Subscription(context, callback, priority)\r\n    listenerData._topics = []\r\n    listenerData.trigger = function (data) {\r\n        this._topics.forEach(function (topic) {\r\n            removeListener(topic, this)\r\n        }, this)\r\n        return this.callback.call(this.context, data)\r\n    }\r\n    topics.split(/\\s+/).forEach(function (directions) {\r\n        var topicObject = this.get(directions, true)\r\n        listenerData._topics.push(topicObject)\r\n        insertListener(topicObject, listenerData)\r\n    }, this)\r\n\r\n    return listenerData\r\n}\r\n\r\n//  _Method_ __off__\r\n//  \r\n//  +   __String__ `topic` the event type  \r\n//  +   _optional_ __function|subscriptionRef|string__ `callback`  \r\n//    + If you do not pass a callback then all subscriptions will be removed from that topic\r\n//    + If you pass a string then all subscriptions with a callback name matching that string will be remove\r\n//    + If you pass a function then all subscriptions with that function will be removed\r\nproto.off = function (topics, callback) {\r\n    if (typeof topics !== 'string') {\r\n        if ( !callback )\r\n            return removeListener(this, topics) // `topics` in this case being the `callback`\r\n        else \r\n            throw 'Bad topic argument'\r\n    }\r\n    if ( arguments.length ) {\r\n        topics.split(/\\s+/).forEach(function (topic) {\r\n            topic = this.get(topic, false)\r\n            if ( topic )\r\n                removeListener(topic, callback)\r\n        }, this)\r\n    // Clear everything\r\n    } else {\r\n        Object.keys(this).forEach(function (key) {\r\n            // Check that it isn't some special property\r\n            if ( this[key] instanceof Bus ) {\r\n                delete this[key]\r\n            }\r\n        }, this)\r\n        this._listeners = []\r\n    }\r\n}\r\n\n//@ sourceURL=/home/jkroso/Dev/Libraries/Bus/src/index.js","module.exports = Subscription\r\n\r\nfunction Subscription (context, callback, priority) {\r\n    if ( typeof callback !== 'function' || typeof priority !== 'number' )\r\n        throw 'Incorrect argument format'\r\n    this.context = context\r\n    this.callback = callback\r\n    this.priority = priority\r\n}\r\n\r\nvar proto = Subscription.prototype\r\n\r\nproto.trigger = function (data) {\r\n    return this.callback.call(this.context, data)\r\n}\r\n\n//@ sourceURL=/home/jkroso/Dev/Libraries/Bus/src/Subscription.js"];Bus=r(0)}();