!function(){function n(e){var t=r[e];return"string"==typeof t&&Function("module","exports","require","eval("+JSON.stringify(t+"\n//@ sourceURL=/"+e)+")").call((r[e]=t={exports:{}}).exports,t,t.exports,n),t.exports}var r=["var Subscription = require(1)\r\n  , keys = Object.keys\r\n\r\nexports = module.exports = Bus\r\n\r\nfunction Bus () {\r\n	this._subs = []\r\n}\r\n\r\nvar proto = Bus.prototype\r\n\r\n/**\r\n * Iterate over a list of listeners invoking each one\r\n * @param  {Array}   topics should be an array of listener arrays from the topics objects you wish to invoke\r\n * @param  {Any}     data   whatever you want passed to each of the subscribers\r\n * @return {Boolean}        true if no listeners prevented propagation\r\n */\r\nexports.invokeList = invokeList\r\nfunction invokeList (topics, data) {\r\n	var len = topics.length, i, listeners\r\n	while ( len-- ) {\r\n		listeners = topics[len]\r\n		i = listeners.length\r\n		while (i--) {\r\n			if (listeners[i].trigger(data) === false) return false\r\n		}\r\n	}\r\n	return true\r\n}\r\n\r\nfunction insertListener (node, sub) {\r\n	node._subs = [sub].concat(node._subs)\r\n}\r\n\r\n// Recursive collect with the ability to fork and combine\r\nexports.branchingCollect = branchingCollect\r\nfunction branchingCollect (node, directive) {\r\n	var i = 0,\r\n		len = directive.length,\r\n		direction,\r\n		key,\r\n		result = [node._subs]\r\n	while ( i < len ) {\r\n		direction = directive[i++]\r\n		key = direction[0]\r\n		if ( key in node ) {\r\n			result = result.concat(branchingCollect(node[key], direction.slice(1)))\r\n		}\r\n	}\r\n	return result\r\n}\r\n\r\n// Takes an list of directions to follow and collects all listeners along the way\r\nexports.collect = collect\r\nfunction collect (node, directions) {\r\n	var result = [node._subs],\r\n		len = directions.length,\r\n		i = 0\r\n	while ( i < len ) {\r\n		node = node[directions[i++]]\r\n		if ( node )\r\n			result.push(node._subs)\r\n		else\r\n			break\r\n	}\r\n	return result\r\n}\r\n\r\nvar reserved = ['on', 'off', 'get', 'emit', '_subs'].reduce(function (o, w) {\r\n	return o[w] = true, o\r\n}, Object.create(null))\r\n\r\nproto.get = function (directions, useforce) {\r\n	if (typeof directions === 'string') directions = directions.split('.')\r\n	var topic = this \r\n	  , edge \r\n	  , i = 0\r\n	\r\n	while (edge = directions[i++]) {\r\n		if (topic[edge])\r\n			if (reserved[edge]) throw new Error('Reserved word: '+edge)\r\n			else topic = topic[edge]\r\n		else if (useforce) topic = topic[edge] = new Bus\r\n		else break\r\n	}\r\n	return topic\r\n}\r\n\r\n/**\r\n * If any callback returns false we immediately exit otherwise we simply \r\n * return true to indicate that all callbacks were fired without interference\r\n * @param  {String} topic   the event type\r\n * @param  {Any}    data    any data you want passed to the callbacks\r\n * @return {Boolean}\r\n */\r\nproto.emit = function (topic, data) {\r\n	if ( typeof topic === 'string' ) {\r\n		topic = collect(this, topic.split('.'))\r\n	} else {\r\n		data = topic\r\n		topic = [this._subs]\r\n	}\r\n	return invokeList(topic, data)\r\n}\r\n\r\nproto.on = function (topics, callback, context) {\r\n	if (typeof topics !== 'string') {\r\n		callback = topics\r\n		context = callback\r\n		topics = ''\r\n	}\r\n	if (!(callback instanceof Subscription))\r\n		callback = new Subscription(callback, context)\r\n\r\n	topics.split(/\\s*\\|\\|\\s*/).forEach(function (directions) {\r\n		directions = this.get(directions, true)\r\n		callback.register(directions)\r\n		insertListener(directions, callback)\r\n	}, this)\r\n\r\n	return callback\r\n}\r\n\r\n/**\r\n * Create function to filter subscriptions and notify those which don't make the cut\r\n * @api private\r\n */\r\nfunction makeChecker (callback, node) {\r\n	switch (typeof callback) {\r\n		case 'function':\r\n			return function (s) {\r\n				if (s.callback !== callback) return true\r\n				s.deregister(node)\r\n			}\r\n		case 'string':\r\n			return function (s) {\r\n				if (s.callback.name !== callback) return true\r\n				s.deregister(node)\r\n			}\r\n		case 'object':\r\n			return function (s) {\r\n				if (s !== callback) return true\r\n				s.deregister(node)\r\n			}\r\n		default:\r\n			// if the user didn't pass a callback, all listeners will be removed\r\n			return function (s) {s.deregister(node)}\r\n	}\r\n}\r\n\r\n/**\r\n * Filter the current topics subscriptions and recurse on its sub-topics\r\n * @api private\r\n */\r\nfunction removeListener (node, checker) {\r\n	var topics = keys(node)\r\n	  , count = 0\r\n	topics.forEach(function (topic) {\r\n		if (!reserved[topic]) {\r\n			var subs = removeListener(node[topic], checker)\r\n			if (!subs) delete node[topic]\r\n			count += subs\r\n		}\r\n	})\r\n	// Is the node still worth having around?\r\n	return (node._subs = node._subs.filter(checker)).length + count\r\n}\r\n\r\nfunction del (node, child) {\r\n	(function notifyAll (node) {\r\n		node._subs.forEach(function (sub) {\r\n			sub.deregister(node)\r\n		})\r\n		keys(node).forEach(function (topic) {\r\n			if (!reserved[topic]) notifyAll(node[topic])\r\n		})\r\n	})(node[child]);\r\n	delete node[child]\r\n}\r\n\r\nproto.off = function (topics, callback) {\r\n	if (typeof topics === 'string') {\r\n		if (callback != null) {\r\n			topics.split(/\\s*\\|\\|\\s*/).forEach(function (topic) {\r\n				var node = this.get(topic)\r\n				if (node && !removeListener(node, makeChecker(callback, node))) {\r\n					node = topic.split('.')\r\n					topic = node.pop()\r\n					node = this.get(node.join('.'));\r\n					delete node[topic]\r\n				}\r\n			}, this)\r\n		}\r\n		else {\r\n			topics.split(/\\s*\\|\\|\\s*/).forEach(function (topic) {\r\n				topic = topic.split('.')\r\n				callback = topic.pop()\r\n				topic = this.get(topic.join('.'))\r\n				if (topic && topic[callback]) del(topic, callback)\r\n			}, this)\r\n		}\r\n	}\r\n	else {\r\n		if (topics) {\r\n		// `topics` in this case being the `callback`\r\n			removeListener(this, makeChecker(topics, this))\r\n		}\r\n		else {\r\n		// Clean the slate\r\n			Object.keys(this).forEach(function (key) {\r\n				if (!reserved[key]) del(this, key)\r\n			}, this)\r\n			this._subs = []\r\n		}\r\n	}\r\n}\r\n\n//@ sourceURL=/home/jkroso/Dev/Libraries/Bus/src/index.js","module.exports = Subscription\r\n\r\nfunction Subscription (callback, context) {\r\n    this.callback = callback\r\n    this.context = context\r\n    this.nodes = []\r\n}\r\n\r\nvar proto = Subscription.prototype\r\n\r\nproto.trigger = function (data) {\r\n    return this.callback.call(this.context, data)\r\n}\r\n\r\nproto.register = function (node) {\r\n	this.nodes = this.nodes.slice()\r\n    this.nodes.push(node)\r\n	return this\r\n}\r\n\r\nproto.deregister = function (node) {\r\n    this.nodes = this.nodes.filter(function (n) {return n !== node})\r\n    return this\r\n}\r\n\r\nproto.once = function () {\r\n	var trigger = this.trigger\r\n	this.trigger = function (data) {\r\n		this.remove()\r\n        return trigger.call(this, data)\r\n    }\r\n}\r\n\r\nproto.remove = function () {\r\n    this.nodes.forEach(function (topic) {\r\n        topic.off(this)\r\n    }, this)\r\n    this.nodes = []\r\n	return this\r\n}\r\n\n//@ sourceURL=/home/jkroso/Dev/Libraries/Bus/src/Subscription.js"];Bus=n(0)}();